{"/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/test.js":"/* istanbul instrument in package npmtest_smoke_and_mirrors */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/lib.npmtest_smoke_and_mirrors.js":"/* istanbul instrument in package npmtest_smoke_and_mirrors */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_smoke_and_mirrors = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_smoke_and_mirrors = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-smoke-and-mirrors && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_smoke_and_mirrors */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_smoke_and_mirrors\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_smoke_and_mirrors.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_smoke_and_mirrors.rollup.js'] =\n            local.assetsDict['/assets.npmtest_smoke_and_mirrors.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_smoke_and_mirrors.__dirname + '/lib.npmtest_smoke_and_mirrors.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/index.js":"// jscs: disable\n/* jshint node: true */\n'use strict';\n\nvar chalk = require('chalk');\nvar stripClassCallCheck = require('babel5-plugin-strip-class-callcheck');\nvar filterImports = require('babel-plugin-filter-imports');\nvar Funnel = require('broccoli-funnel');\n\nmodule.exports = {\n  name: 'smoke-and-mirrors',\n\n  init: function() {\n    this._super.init && this._super.init.apply(this, arguments);\n\n    this.options = this.options || {};\n  },\n\n  _hasSetupBabelOptions: false,\n  _setupBabelOptions: function(env) {\n    if (this._hasSetupBabelOptions) {\n      return;\n    }\n\n    var babelOptions = this.options.babel = this.options.babel || {};\n\n    babelOptions.plugins = babelOptions.plugins || [];\n    babelOptions.plugins.push({ transformer: stripClassCallCheck, position: 'after' });\n\n    if (/production/.test(env)) {\n      babelOptions.plugins.push(\n        filterImports({\n        'smoke-and-mirrors/-debug/helpers': [\n          'assert',\n          'warn',\n          'debug',\n          'instrument',\n          'deprecate',\n          'stripInProduction'\n        ]})\n      );\n    }\n\n    this._hasSetupBabelOptions = true;\n  },\n\n  included: function(app) {\n    this._super.included.apply(this, arguments);\n\n    while (typeof app.import !== 'function' && app.app) {\n      app = app.app;\n    }\n\n    if (typeof app.import !== 'function') {\n      throw new Error('smoke-and-mirrors is being used within another addon or engine ' +\n        'and is having trouble registering itself to the parent application.');\n    }\n\n    this._setupBabelOptions(app.env);\n\n    if (!/production/.test(app.env)) {\n      this.ui.write(\n        chalk.grey(\"\\n===================================================================\\n\") +\n        chalk.cyan(\"\\tSmoke-and-mirrors\\n\") +\n        chalk.grey(\"\\t:: Including CSS for Visual Debugger\\n\") +\n        chalk.grey(\"\\t:: (included in non production builds only)\\n\") +\n        chalk.grey(\"\\t:: To use, set \") + chalk.yellow(\"{{vertical-collection debug=true}}\") +\n        chalk.grey(\"\\n===================================================================\\n\")\n      );\n\n      app.import('./vendor/debug.css');\n    }\n  },\n\n  treeForAddon: function() {\n    var tree = this._super.treeForAddon.apply(this, arguments);\n\n    if (/production/.test(this.parent.env)) {\n      tree = new Funnel(tree, { exclude: [ /-debug/ ] });\n    }\n\n    return tree;\n  },\n\n  treeForApp: function() {\n    var tree = this._super.treeForApp.apply(this, arguments);\n\n    if (/production/.test(this.parent.env)) {\n      tree = new Funnel(tree, { exclude: [ /initializers/ ] });\n    }\n\n    return tree;\n  },\n\n  isDevelopingAddon: function() {\n    return false;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/config/changelog.js":"// jshint node:true\n\n// For details on each option run `ember help release`\nmodule.exports = {\n\n  // angular style guide: https://github.com/angular/angular.js/blob/v1.4.8/CONTRIBUTING.md#commit\n  // jquery style guide: https://contribute.jquery.org/commits-and-pull-requests/#commit-guidelines\n  // ember style guide: https://github.com/emberjs/ember.js/blob/master/CONTRIBUTING.md#commit-tagging\n  style: 'angular', // 'ember' 'jquery'\n\n  head: 'develop',\n  base: '-last', // a branch or tag name, `-last` defaults to the version in package.json\n\n  hooks: {\n    /*\n     parser: function(commit) { return commit; }\n     filter: function(commit) { return true; },\n     groupSort: function(commits) { return { commits: commits }; },\n     format: function(commit) { return commit.title; },\n     */\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/config/environment.js":"/*jshint node:true*/\n'use strict';\n\nmodule.exports = function(/* environment, appConfig */) {\n  return { };\n};\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/config/release.js":"/* jshint node:true */\n// var RSVP = require('rsvp');\nvar generateChangelog = require('ember-cli-changelog/lib/tasks/release-with-changelog');\n\n// For details on each option run `ember help release`\nmodule.exports = {\n  // local: true,\n  // remote: 'some_remote',\n  // annotation: \"Release %@\",\n  // message: \"Bumped version to %@\",\n  // manifest: [ 'package.json', 'bower.json', 'someconfig.json' ],\n  // publish: true,\n  // strategy: 'date',\n  // format: 'YYYY-MM-DD',\n  // timezone: 'America/Los_Angeles',\n\n  beforeCommit: generateChangelog\n\n};\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/-debug/helpers.js":"import Ember from 'ember';\n\nconst {\n  assert: emberAssert,\n  warn: emberWarn,\n  deprecate: emberDeprecate,\n  Logger\n} = Ember;\n\nexport function instrument(cb) {\n  cb();\n}\n\nexport function debug() {\n  Logger.debug(...arguments);\n}\n\nexport function assert() {\n  emberAssert(...arguments);\n}\n\nexport function warn() {\n  emberWarn(...arguments);\n}\n\nexport function deprecate() {\n  emberDeprecate(...arguments);\n}\n\nexport function stripInProduction(cb) {\n  cb();\n}\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/-debug/index.js":"import DebugMixin from './edge-visualization/debug-mixin';\nimport Collection from '../components/vertical-collection/component';\n\nCollection.reopen(DebugMixin);\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/services/in-viewport.js":"import Ember from 'ember';\nimport Radar from '../-private/radar/models/radar';\n\nconst {\n  Service\n  } = Ember;\n\nexport default Service.extend({\n\n  radar: null,\n  minimumMovement: 15,\n  resizeDebounce: 64,\n\n  register(component) {\n    this.radar.register(component);\n  },\n\n  unregister(component) {\n    this.radar.unregister(component);\n  },\n\n  _activateRadar() {\n    const resizeDebounce = this.get('resizeDebounce');\n    const minimumMovement = this.get('minimumMovement');\n\n    this.radar = new Radar({\n      sky: document.body,\n      telescope: window,\n      minimumMovement,\n      resizeDebounce\n    });\n  },\n\n  willDestroy() {\n    this._super(...arguments);\n    this.radar.destroy();\n    this.radar = null;\n  },\n\n  init() {\n    this._super(...arguments);\n    this._activateRadar();\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/utils/get-tag-descendant.js":"/*\n * automatic tag matching for lists, selects, and tables\n *\n * @param {String} tag an html tagName\n * @returns {String} tag a new html tagName\n */\nexport default function getTagDescendant(tag) {\n  switch (tag) {\n  case 'vertical-collection':\n    return 'vertical-item';\n  case 'horizontal-collection':\n    return 'horizontal-item';\n  case 'tbody':\n  case 'table':\n  case 'thead':\n  case 'tfoot':\n    return 'tr';\n  case 'tr':\n  case 'th':\n    return 'td';\n  case 'ul':\n  case 'ol':\n    return 'li';\n  case 'select':\n  case 'optgroup':\n    return 'option';\n  default:\n    return 'div';\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/utils/proxied-array.js":"import Ember from 'ember';\nimport keyForItem from '../-private/ember/utils/key-for-item';\n\nconst {\n  computed,\n  ArrayProxy,\n  ObjectProxy,\n  get\n} = Ember;\n\nfunction valueForIndex(arr, index) {\n  return arr.objectAt ? arr.objectAt(index) : arr[index];\n}\n\nfunction changeIsPrepend(oldArray, newArray, keyPath) {\n  const lengthDifference = get(newArray, 'length') - get(oldArray, 'length');\n\n  // if either array is empty or the new array is not longer, do not treat as prepend\n  if (!get(newArray, 'length') || !get(oldArray, 'length') || lengthDifference <= 0) {\n    return false;\n  }\n\n  // if the keys at the correct indexes are the same, this is a prepend\n  const oldInitialItem = get(valueForIndex(oldArray, 0), 'content');\n  const oldInitialKey = keyForItem(oldInitialItem, keyPath, 0);\n  const newInitialItem = valueForIndex(newArray, lengthDifference);\n  const newInitialKey = keyForItem(newInitialItem, keyPath, lengthDifference);\n\n  return oldInitialKey === newInitialKey;\n}\n\nexport default function proxiedArray(arrayKey, keyPath = '@identity') {\n  // create the value cache for the array\n  const outbound = ArrayProxy.create({ content: Ember.A() });\n\n  // create the computed args array\n  const args = [];\n\n  args.push(arrayKey.indexOf('.[]') !== -1 ? arrayKey : `${arrayKey}.[]`);\n\n  const fn = () => {\n    const inbound = this.get(arrayKey);\n\n    if (!inbound || !get(inbound, 'length')) {\n      outbound.clear();\n      return outbound;\n    }\n    let newLength;\n    const newObjects = Ember.A();\n    let diff;\n\n    outbound.beginPropertyChanges();\n\n    // handle additions to the beginning of the array\n    if (changeIsPrepend(outbound, inbound, keyPath)) {\n      newLength = get(inbound, 'length');\n      diff = newLength - outbound.get('length');\n      for (let i = 0; i < diff; i++) {\n        newObjects.push(ObjectProxy.create({ content: inbound[i] }));\n      }\n      if (newObjects.length) {\n        outbound.replace(0, 0, newObjects);\n      }\n\n    // handle additions and inline changes\n    } else {\n      inbound.forEach((item, index) => {\n        const proxiedObject = outbound.objectAt(index);\n\n        if (proxiedObject) {\n          proxiedObject.set('content', item);\n        } else {\n          newObjects.push(ObjectProxy.create({ content: item }));\n        }\n      });\n\n      if (newObjects.length) {\n        outbound.pushObjects(newObjects);\n      }\n    }\n\n    newLength = inbound ? get(inbound, 'length') : 0;\n\n    if (newLength < outbound.get('length')) {\n      diff = outbound.get('length') - newLength;\n      outbound.removeAt(newLength, diff);\n    }\n\n    outbound.endPropertyChanges();\n    outbound.notifyPropertyChange('length');\n    return outbound;\n  };\n\n  args.push(fn);\n  return computed.apply(this, args);\n}\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/app/components/in-viewport.js":"export { default } from 'smoke-and-mirrors/components/in-viewport/component';\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/app/components/occludable-area.js":"export { default } from 'smoke-and-mirrors/components/occludable-area/component';\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/app/components/pre-render.js":"export { default } from 'smoke-and-mirrors/components/pre-render/component';\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/app/components/vertical-collection.js":"export { default } from 'smoke-and-mirrors/components/vertical-collection/component';\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/app/components/vertical-item.js":"export { default } from 'smoke-and-mirrors/components/vertical-item/component';\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/app/initializers/debug.js":"import 'smoke-and-mirrors/-debug';\n\nexport default {\n  name: 'smoke-and-mirrors-debug',\n  initialize() {}\n};\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/app/services/in-viewport.js":"import Service from 'smoke-and-mirrors/services/in-viewport';\n\nexport default Service;\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/components/in-viewport/component.js":"import Ember from 'ember';\nimport layout from './template';\n\nconst {\n  Component,\n  inject\n  } = Ember;\n\nexport default Component.extend({\n  layout,\n  attributeBindings: ['zoneX:x', 'zoneY:y'],\n\n  inViewport: inject.service('in-viewport'),\n\n  zoneX: 0,\n  zoneY: 0,\n\n  didInsertElement() {\n    this._super(...arguments);\n    this.get('inViewport').register(this);\n  },\n\n  willDestroyElement() {\n    this._super(...arguments);\n    this.get('inViewport').unregister(this);\n  },\n\n  willDestroy() {\n    this._super(...arguments);\n    this.get('inViewport').unregister(this);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/components/occludable-area/component.js":"import Ember from 'ember';\nimport layout from './template';\n\nconst {\n  Component,\n  inject\n  } = Ember;\n\nexport default Component.extend({\n  layout,\n  hasRendered: false,\n  isRendered: false,\n  occludeAt: 3,\n\n  satellite: null,\n  inViewport: inject.service('in-viewport'),\n\n  didInsertElement() {\n    this._super();\n    this.get('inViewport').register(this);\n  },\n\n  willDestroyElement() {\n    this._super();\n    this.get('inViewport').unregister(this);\n  },\n\n  willDestroy() {\n    this._super();\n    this.get('inViewport').unregister(this);\n  },\n\n  registerSatellite(satellite) {\n    this.satellite = satellite;\n    satellite.didShift = () => {\n      const zones = satellite.radar.getSatelliteZones(satellite);\n\n      this._shouldRender(zones);\n    };\n  },\n  unregisterSatellite() {\n    this.satellite.didShift = null;\n    this.satellite = null;\n  },\n\n  shouldRender: true,\n  _shouldRender(zones) {\n    const zoneX = zones.x;\n    const zoneY = zones.y;\n    const occludeAt = this.get('occludeAt');\n    let willRender;\n\n    if (zoneX > (-1 * occludeAt) && zoneX < occludeAt) {\n      willRender = (zoneY > (-1 * occludeAt) && zoneY < occludeAt);\n    }\n\n    if (!willRender && !this.hasRendered && zoneX < 0 || zoneY < 0) {\n      this.hasRendered = true;\n      this.set('shouldRender', true);\n      return;\n    }\n\n    if (!willRender) {\n      if (this.isRendered) {\n        this.element.style.height = `${this.satellite.geography.height}px`;\n        this.element.style.width = `${this.satellite.geography.width}px`;\n        this.isRendered = false;\n      }\n    } else if (!this.isRendered) {\n      this.element.style.height = '';\n      this.element.style.width = '';\n      this.isRendered = true;\n    }\n\n    this.set('shouldRender', willRender);\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/components/pre-render/component.js":"import Ember from 'ember';\nimport layout from './template';\nimport getDimensions from '../../utils/element/get-dimensions';\nimport applyDimensions from '../../utils/element/apply-dimensions';\n\nconst {\n  computed,\n  Component,\n  observer,\n  run\n} = Ember;\n\nexport default Component.extend({\n  layout,\n\n  renderInParent: false,\n  parent: null, // parent element\n  destination: computed('renderInParent', 'parent', function() {\n    const renderInParent = this.get('renderInParent');\n    const parent = this.get('parent');\n\n    this.__smAppendBody((parent || this.element).cloneNode(false));\n    return renderInParent ? (parent || this.element) : this._fragmentBody;\n  }),\n\n  didPreRender(/* dimensions */) {},\n  didMoveElement() {},\n\n  __smGetComputedStyle() {\n    const bodyStyle = getDimensions(this._fragmentBody);\n\n    this.didPreRender(bodyStyle);\n  },\n\n  __smUpdateFragmentStyles() {\n    const parent = this.get('parent') || this.element;\n\n    if (parent === this.element) {\n      if (!this.get('parentElementDidInsert')) {\n        return;\n      }\n    }\n\n    const parentWrapper = parent.parentNode;\n    const computedStyle = getDimensions(parentWrapper);\n\n    applyDimensions(this._fragmentWrapper, computedStyle);\n\n    this.__smGetComputedStyle();\n  },\n\n  _fragment: null,\n  _fragmentWrapper: null,\n  _fragmentBody: null,\n  __smSetupFragment() {\n    if (this._fragment) {\n      return;\n    }\n    const fragment = document.createElement('div');\n\n    fragment.style.position = 'absolute';\n    fragment.style.maxWidth = '9999px';\n    fragment.style.top = '0px';\n    fragment.style.left = '-10000px';\n    fragment.style.opacity = 0;\n\n    this._fragment = fragment;\n    this._fragmentWrapper = document.createElement('div');\n    fragment.appendChild(this._fragmentWrapper);\n    document.body.appendChild(fragment);\n  },\n\n  __smAppendBody(clone) {\n    this._fragmentBody = clone;\n    this._fragmentWrapper.appendChild(clone);\n  },\n\n  willInsertElement() {\n    this._super(...arguments);\n    this._firstNode = this.element.firstChild;\n    this._lastNode = this.element.lastChild;\n    this.appendToDestination();\n  },\n\n  didInsertElement() {\n    this.set('parentElementDidInsert', true);\n    if (!this.get('parent')) {\n      this.__smUpdateFragmentStyles();\n    }\n  },\n\n  willDestroyElement() {\n    this._super(...arguments);\n    const firstNode = this._firstNode;\n    const lastNode = this._lastNode;\n\n    run.schedule('render', () => {\n      this.removeRange(firstNode, lastNode);\n    });\n  },\n\n  willDestroy() {\n    this._super(...arguments);\n    this._fragment = null;\n    this._fragmentBody = null;\n    this._fragmentWrapper = null;\n  },\n\n  destinationDidChange: observer('destination', function() {\n    const destinationElement = this.get('destination');\n\n    if (destinationElement !== this._firstNode.parentNode) {\n      run.schedule('render', this, 'appendToDestination');\n    }\n  }),\n\n  appendToDestination() {\n    const destinationElement = this.get('destination');\n    const currentActiveElement = document.activeElement;\n\n    this.appendRange(destinationElement, this._firstNode, this._lastNode);\n    if (document.activeElement !== currentActiveElement) {\n      currentActiveElement.focus();\n    }\n\n    if (destinationElement === this._fragmentBody) {\n      this.__smUpdateFragmentStyles();\n    }\n\n    this.didMoveElement();\n  },\n\n  appendRange(destinationElement, firstNode, lastNode) {\n    while (firstNode) {\n      destinationElement.insertBefore(firstNode, null);\n      firstNode = firstNode !== lastNode ? lastNode.parentNode.firstChild : null;\n    }\n  },\n\n  removeRange(firstNode, lastNode) {\n    let node = lastNode;\n\n    do {\n      const next = node.previousSibling;\n\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n        if (node === firstNode) {\n          break;\n        }\n      }\n      node = next;\n    } while (node);\n  },\n\n  init() {\n    this._super(...arguments);\n    this.__smSetupFragment();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/components/vertical-collection/component.js":"/* global Array, parseFloat, Math */\nimport Ember from 'ember';\nimport layout from './template';\nimport getTagDescendant from '../../utils/get-tag-descendant';\nimport proxied from '../../utils/proxied-array';\nimport ListRadar from '../../-private/radar/models/list-radar';\nimport identity from '../../-private/ember/utils/identity';\nimport scheduler from '../../-private/scheduler';\n\nconst {\n  K,\n  get,\n  computed,\n  Component,\n  Logger,\n  isBlank,\n  getOwner\n} = Ember;\n\nfunction valueForIndex(arr, index) {\n  return arr.objectAt ? arr.objectAt(index) : arr[index];\n}\n\nfunction getContent(obj, isProxied) {\n  const key = isProxied ? 'content.content' : 'content';\n\n  return get(obj, key);\n}\n\nconst VerticalCollection = Component.extend({\n  /*\n   * Defaults to `vertical-collection`.\n   *\n   * If itemTagName is blank or null, the `vertical-collection` will [tag match](../addon/utils/get-tag-descendant.js)\n   * with the `vertical-item`.\n   */\n  tagName: 'vertical-collection',\n  layout,\n\n  content: computed.alias('items'),\n  items: undefined,\n\n  // –––––––––––––– Required Settings\n\n  /*\n   * This height is used to give the `vertical-item`s height prior to\n   * it's content being rendered.\n   *\n   * This height is replaced with the actual rendered height once content\n   * is rendered for the first time.\n   */\n  defaultHeight: 75,\n  alwaysRemeasure: false,\n  alwaysUseDefaultHeight: computed.not('alwaysRemeasure'),\n\n  /*\n   * Cached value used once default height is\n   * calculated firmly\n   */\n  _defaultHeight: null,\n\n  // –––––––––––––– Optional Settings\n\n  /*\n   * Classes to add to the `vertical-item`\n   */\n  itemClassNames: '',\n\n  // –––––––––––––– Optional Settings\n  /*\n   * A jQuery selector string that will select the element from\n   * which to calculate the viewable height and needed offsets.\n   *\n   * This element will also have the `scroll` event handler added to it.\n   *\n   * Usually this element will be the component's immediate parent element,\n   * if so, you can leave this null.\n   *\n   * Set this to \"body\" to scroll the entire web page.\n   */\n  containerSelector: null,\n\n  /*\n   * Used if you want to explicitly set the tagName of collection's items\n   */\n  itemTagName: '',\n  key: '@identity',\n\n  // –––––––––––––– Performance Tuning\n  /*\n   * how much extra room to keep visible and invisible on\n   * either side of the viewport.\n   *\n   * This used to be two separate values (invisibleBuffer/visibleBuffer)\n   * but these values have been unified to ease a future transition in\n   * the internal mechanics of the collection to utilize DOM recycling.\n   */\n  bufferSize: 0.25,\n\n  /*\n   * useContentProxy\n   */\n  useContentProxy: false,\n\n  // –––––––––––––– Initial State\n  /*\n   *  If set, this will be used to set\n   *  the scroll position at which the\n   *  component initially renders.\n   */\n  scrollPosition: 0,\n\n  /*\n   * If set, if scrollPosition is empty\n   * at initialization, the component will\n   * render starting at the bottom.\n   */\n  renderFromLast: false,\n  __isInitializingFromLast: false,\n\n  /*\n   * If set, all items will initially be revealed\n   * so that their dimensions can be correctly\n   * determined\n   */\n  renderAllInitially: false,\n  _isFirstRender: true,\n\n  /*\n   * If set, upon initialization the scroll\n   * position will be set such that the item\n   * with the provided id is at the top left\n   * on screen.\n   *\n   * If the item cannot be found, scrollTop\n   * is set to 0.\n   */\n  idForFirstItem: null,\n\n  // –––––––––––––– Actions\n  /*\n   * Specify an action to fire when the last item is reached.\n   *\n   * This action will only fire once per unique last item, and\n   * is fired the moment the last element is visible, it does\n   * not need to be on screen yet.\n   *\n   * It will include the index and content of the last item,\n   * as well as a promise.\n   *\n   * ```\n   * {\n   *  index: 0,\n   *  item : {},\n   *  promise: fn\n   * }\n   * ```\n   *\n   * The promise should be resolved once any loading is complete, or\n   * rejected if loading has failed.\n   *\n   * If `loadingComponentClass` is defined, it will be inserted above existing content.\n   *\n   * Rejecting the promise leaves the loadingComponent in place for 5s and set's\n   * it's `loadingFailed` property to true.\n   *\n   */\n  firstReached: null,\n\n  /*\n   * Specify an action to fire when the first item is reached.\n   *\n   * This action will only fire once per unique first item, and\n   * is fired the moment the first element is visible, it does\n   * not need to be on screen yet.\n   *\n   * It will include the index and content of the first item\n   * as well as a promise.\n   *\n   * ```\n   * {\n   *  index: 0,\n   *  item : {},\n   *  promise: fn\n   * }\n   * ```\n   *\n   * The promise should be resolved once any loading is complete, or\n   * rejected if loading has failed.\n   *\n   * If `loadingViewClass` is defined, it will be inserted above existing content.\n   *\n   * Rejecting the promise leaves the loadingView in place for 5s and set's\n   * it's `loadingFailed` property to true.\n   *\n   */\n  lastReached: null,\n\n  /*\n   * Specify an action to fire when the first on-screen item\n   * changes.\n   *\n   * It includes the index and content of the item now visible.\n   */\n  firstVisibleChanged: null,\n\n  /*\n   * Specify an action to fire when the last on-screen item\n   * changes.\n   *\n   * It includes the index and content of the item now visible.\n   */\n  lastVisibleChanged: null,\n\n  _content: null,\n\n  // –––––––––––––– Private Internals\n  _firstVisibleIndex: 0,\n\n  /*\n   * a cached element reference to the container \"viewport\" element\n   * this is known as the \"telescope\" within the Radar class.\n   */\n  _container: null,\n\n  /*\n   * Set this to false to prevent rendering entirely.\n   * Useful for situations in which rendering is\n   * expensive enough that it interferes with a\n   * transition animation.\n   *\n   * In such cases, set this to false, and switch it\n   * to true once animation has completed.\n   */\n  shouldRender: true,\n\n  /*\n   * forward is true, backwards is false\n   */\n  _scrollIsForward: 0,\n  radar: null,\n  _nextUpdate: null,\n  _nextSync: null,\n  _nextScrollSync: null,\n  _isPrepending: false,\n  _children: null,\n\n  keyForItem(item, index) {\n    let key;\n    const keyPath = this.get('key');\n\n    switch (keyPath) {\n      case '@index':\n        // allow 0 index\n        if (!index && index !== 0) {\n          throw new Error('No index was supplied to keyForItem');\n        }\n        key = index;\n        break;\n      case '@identity':\n        key = identity(item);\n        break;\n      default:\n        if (keyPath) {\n          key = get(item, keyPath);\n        } else {\n          key = identity(item);\n        }\n    }\n\n    if (typeof key === 'number') {\n      key = String(key);\n    }\n\n    return key;\n  },\n\n  // –––––––––––––– Action Helper Functions\n  canSendActions(name /* context*/) {\n    // don't trigger during a prepend or initial render\n    if (this._isFirstRender || this._isPrepending) {\n      return false;\n    }\n\n    if (name === 'firstReached') {\n      if (this._scrollIsForward) {\n        return false;\n      }\n    }\n\n    return !(name === 'lastReached' && !this._scrollIsForward);\n  },\n\n  prepareActionContext(name, context) {\n    const isProxied = this.get('useContentProxy');\n\n    if (name === 'didMountCollection') {\n      if (context.firstVisible.item) {\n        context.firstVisible.item = getContent(context.firstVisible.item, isProxied);\n      }\n\n      if (context.lastVisible.item) {\n        context.lastVisible.item = getContent(context.lastVisible.item, isProxied);\n      }\n\n      return context;\n    }\n\n    context.item = getContent(context.item, isProxied);\n    return !context.item ? false : context;\n  },\n\n  keyForContext(context) {\n    return this.keyForItem(context.item, context.index);\n  },\n\n  __smActionCache: null,\n  sendActionOnce(name, context) {\n    if (!this.canSendActions(name, context)) {\n      return;\n    }\n\n    context = this.prepareActionContext(name, context);\n    if (!context) {\n      return;\n    }\n\n    const contextCache = this.__smActionCache;\n\n    if (contextCache.hasOwnProperty(name)) {\n      const contextKey = this.keyForContext(context);\n\n      if (contextCache[name] === contextKey) {\n        return;\n      }\n      contextCache[name] = contextKey;\n    }\n\n    // this MUST be async or glimmer will freak\n    scheduler.schedule('affect', () => {\n      setTimeout(() => {\n        this.sendAction(name, context, K);\n      });\n    });\n  },\n\n  /*\n   Binary search for finding the topmost visible view.\n   This is not the first visible item on screen, but the first\n   item that will render it's content.\n\n   @method _findFirstRenderedComponent\n   @param {Number} invisibleTop The top/left of the viewport to search against\n   @returns {Number} the index into childViews of the first view to render\n   **/\n  _findFirstRenderedComponent(visibleTop) {\n    const childComponents = this.get('children');\n    let maxIndex = childComponents.length - 1;\n    let minIndex = 0;\n    let midIndex;\n\n    if (maxIndex < 0) {\n      return 0;\n    }\n\n    while (maxIndex > minIndex) {\n      midIndex = Math.floor((minIndex + maxIndex) / 2);\n\n      // in case of not full-window scrolling\n      const component = childComponents[midIndex];\n      const componentBottom = component.satellite.geography.bottom;\n\n      if (componentBottom > visibleTop) {\n        maxIndex = midIndex - 1;\n      } else {\n        minIndex = midIndex + 1;\n      }\n    }\n\n    return minIndex;\n  },\n\n  children: computed('_children.@each.index', function() {\n    const children = this.get('_children');\n    const output = new Array(get(children, 'length'));\n\n    children.forEach((item) => {\n      const index = get(item, 'index');\n      output[index] = item;\n    });\n    return output;\n  }),\n\n  register(child) {\n    this.get('_children').addObject(child);\n    child.radar = this.radar;\n    this._scheduleUpdate();\n  },\n\n  unregister(child) {\n    const children = this.get('_children');\n\n    if (children) {\n      children.removeObject(child);\n      if (!this.get('isDestroying') && !this.get('isDestroyed')) {\n        this._scheduleUpdate();\n      }\n    }\n  },\n\n  /*\n   *\n   * The big question is can we render from the bottom\n   * without the bottom most item being taken off screen?\n   *\n   * Triggers on scroll.\n   *\n   * @private\n   */\n  _updateChildStates(/* source */) {  // eslint: complexity\n    if (!this.get('shouldRender')) {\n      return;\n    }\n\n    const edges = this._edges;\n    const childComponents = this.get('children');\n\n    if (!get(childComponents, 'length')) {\n      return;\n    }\n\n    if (this._isFirstRender) {\n      if (this.get('renderAllInitially')) {\n        childComponents.forEach((i) => {\n          i.show();\n        });\n\n        this._scheduleScrollSync();\n\n        this._isFirstRender = false;\n        return;\n      }\n    }\n\n    const currentViewportBound = this.radar.skyline.top;\n    let currentUpperBound = edges.visibleTop;\n\n    if (currentUpperBound < currentViewportBound) {\n      currentUpperBound = currentViewportBound;\n    }\n\n    const topComponentIndex = this._findFirstRenderedComponent(currentUpperBound);\n    let bottomComponentIndex = topComponentIndex;\n    const lastIndex = childComponents.length - 1;\n    let topVisibleSpotted = false;\n    let toCull = [];\n    const toShow = [];\n\n    while (bottomComponentIndex <= lastIndex) {\n      const component = childComponents[bottomComponentIndex];\n      const componentTop = component.satellite.geography.top;\n      const componentBottom = component.satellite.geography.bottom;\n\n      // end the loop if we've reached the end of components we care about\n      if (componentTop > edges.visibleBottom) {\n        break;\n      }\n\n      // above the upper reveal boundary\n      if (componentBottom < edges.visibleTop) {\n        toCull.push(component);\n\n        // above the upper screen boundary\n      } else if (componentBottom < edges.viewportTop) {\n        toShow.push(component);\n        if (bottomComponentIndex === 0) {\n          this.sendActionOnce('firstReached', {\n            item: component,\n            index: bottomComponentIndex\n          });\n        }\n\n        // above the lower screen boundary\n      } else if (componentTop < edges.viewportBottom) {\n        toShow.push(component);\n        if (bottomComponentIndex === 0) {\n          this.sendActionOnce('firstReached', {\n            item: component,\n            index: bottomComponentIndex\n          });\n        }\n        if (bottomComponentIndex === lastIndex) {\n          this.sendActionOnce('lastReached', {\n            item: component,\n            index: bottomComponentIndex\n          });\n        }\n\n        if (!topVisibleSpotted) {\n          topVisibleSpotted = true;\n          this.set('_firstVisibleIndex', bottomComponentIndex);\n          this.sendActionOnce('firstVisibleChanged', {\n            item: component,\n            index: bottomComponentIndex\n          });\n        }\n\n        // above the lower reveal boundary (componentTop < edges.visibleBottom)\n      } else {\n        toShow.push(component);\n        if (bottomComponentIndex === lastIndex) {\n          this.sendActionOnce('lastReached', {\n            item: component,\n            index: bottomComponentIndex\n          });\n        }\n      }\n\n      bottomComponentIndex++;\n    }\n\n    this.sendActionOnce('lastVisibleChanged', {\n      item: childComponents[bottomComponentIndex - 1],\n      index: bottomComponentIndex - 1\n    });\n\n    toCull = toCull\n      .concat((childComponents.slice(0, topComponentIndex)))\n      .concat(childComponents.slice(bottomComponentIndex));\n\n    for (let j = 0; j < toCull.length; j++) {\n      toCull[j].cull();\n    }\n    for (let k = 0; k < toShow.length; k++) {\n      toShow[k].show();\n    }\n\n    this._scheduleScrollSync();\n\n    if (this._isFirstRender) {\n      this._isFirstRender = false;\n      this.sendActionOnce('didMountCollection', {\n        firstVisible: { item: childComponents[topComponentIndex], index: topComponentIndex },\n        lastVisible: { item: childComponents[bottomComponentIndex - 1], index: bottomComponentIndex - 1 }\n      });\n    }\n  },\n\n  _scheduleUpdate() {\n    if (this._isPrepending) {\n      return;\n    }\n    if (this._nextUpdate === null) {\n      this._nextUpdate = scheduler.schedule('layout', () => {\n        this._updateChildStates();\n        this._nextUpdate = null;\n      });\n    }\n  },\n\n  _scheduleSync() {\n    if (this._nextSync === null) {\n      this._nextSync = scheduler.schedule('sync', () => {\n        this.radar.updateSkyline();\n        this._nextSync = null;\n      });\n    }\n  },\n\n  _scheduleScrollSync() {\n    if (this.get('__isInitializingFromLast')) {\n      if (this._nextScrollSync === null) {\n        this._nextScrollSync = scheduler.schedule('measure', () => {\n          const last = this.element.lastElementChild;\n\n          this.set('__isInitializingFromLast', false);\n          if (last) {\n            last.scrollIntoView(false);\n          }\n\n          this._nextScrollSync = null;\n        });\n      }\n    }\n  },\n\n  didInsertElement() {\n    this.setupContainer();\n    this._computeEdges();\n    this._initializeScrollState();\n    this._scheduleUpdate();\n    // Check are we in dev environment\n    if (getOwner(this).resolveRegistration('config:environment').environment === 'development') {\n      this._checkCssRules();\n    }\n  },\n\n  // –––––––––––––– Setup/Teardown\n  setupContainer() {\n    const containerSelector = this.get('containerSelector');\n    let container;\n\n    if (containerSelector === 'body') {\n      container = window;\n    } else {\n      const $container = containerSelector ? this.$().closest(containerSelector) : this.$().parent();\n\n      container = $container.get(0);\n\n      $container.css({\n        '-webkit-overflow-scrolling': 'touch',\n        'overflow-scrolling': 'touch',\n        'overflow-y': 'scroll'\n      });\n    }\n\n    this._container = container;\n    this.setupHandlers();\n  },\n\n  setupHandlers() {\n    const container = this._container;\n    const onScrollMethod = (dY) => {\n      if (this._isPrepending) {\n        return;\n      }\n      this._scrollIsForward = dY > 0;\n\n      this._scheduleUpdate();\n    };\n\n    const onResizeMethod = () => {\n      this._computeEdges();\n    };\n    const onRebuildMethod = (dY, dX) => {\n      if (this._isPrepending) {\n        return;\n      }\n\n      this._scrollIsForward = dY > 0;\n      this._computeEdges();\n      this._scheduleUpdate();\n    };\n\n    this.radar.setState({\n      telescope: container,\n      sky: this.element,\n      minimumMovement: Math.floor(this.defaultHeight / 2),\n      alwaysRemeasure: this.alwaysRemeasure\n    });\n    this.radar.didResizeSatellites = onResizeMethod;\n    this.radar.didAdjustPosition = onResizeMethod;\n    this.radar.didShiftSatellites = onScrollMethod;\n    this.radar.didRebuild = onRebuildMethod;\n  },\n\n  _initializeScrollState() {\n    const idForFirstItem = this.get('idForFirstItem');\n\n    if (this.scrollPosition) {\n      this.radar.telescope.scrollTop = this.scrollPosition;\n    } else if (this.get('renderFromLast')) {\n      const last = this.$().get(0).lastElementChild;\n\n      this.set('__isInitializingFromLast', true);\n      if (last) {\n        last.scrollIntoView(false);\n      }\n    } else if (idForFirstItem) {\n      const content = this.get('content');\n      let firstVisibleIndex;\n\n      for (let i = 0; i < get(content, 'length'); i++) {\n        if (idForFirstItem === this.keyForItem(valueForIndex(content, i), i)) {\n          firstVisibleIndex = i;\n        }\n      }\n      this.radar.telescope.scrollTop = (firstVisibleIndex || 0) * this.__getEstimatedDefaultHeight();\n    }\n  },\n\n  /*\n   * Remove the event handlers for this instance\n   * and teardown any temporarily cached data.\n   *\n   * if storageKey is set, caches much of it's\n   * state in order to quickly reboot to the same\n   * scroll position on relaunch.\n   */\n  willDestroyElement() {\n    this._destroyCollection();\n  },\n\n  willDestroy() {\n    this._super();\n    this._destroyCollection();\n  },\n\n  _destroyCollection() {\n    // cleanup scroll\n    if (this.radar) {\n      this.radar.destroy();\n      this.radar.didResizeSatellites = null;\n      this.radar.didAdjustPosition = null;\n      this.radar.didShiftSatellites = null;\n      this.radar = null;\n    }\n\n    this.set('_content', null);\n    this.set('_children', null);\n    this._container = null;\n    this.__smActionCache = null;\n\n    // clean up scheduled tasks\n    scheduler.forget(this._nextUpdate);\n    scheduler.forget(this._nextSync);\n    scheduler.forget(this._nextScrollSync);\n  },\n\n  __prependComponents() {\n    this._isPrepending = true;\n    scheduler.forget(this._nextUpdate);\n    this._nextUpdate = scheduler.schedule('sync', () => {\n      this.radar.silentNight();\n      this._updateChildStates();\n      this._isPrepending = false;\n      this._nextUpdate = null;\n    });\n  },\n\n  __getEstimatedDefaultHeight() {\n    let _defaultHeight = this.get('_defaultHeight');\n\n    if (_defaultHeight) {\n      return _defaultHeight;\n    }\n\n    const defaultHeight = `${this.get('defaultHeight')}`;\n\n    if (defaultHeight.indexOf('em') === -1) {\n      _defaultHeight = parseInt(defaultHeight, 10);\n      this.set('_defaultHeight', _defaultHeight);\n      return _defaultHeight;\n    }\n\n    let element;\n\n    // use body if rem\n    if (defaultHeight.indexOf('rem') !== -1) {\n      element = window.document.body;\n      _defaultHeight = 1;\n    } else {\n      element = this.get('element');\n      if (!element || !element.parentNode) {\n        element = window.document.body;\n      } else {\n        _defaultHeight = 1;\n      }\n    }\n\n    const fontSize = window.getComputedStyle(element).getPropertyValue('font-size');\n\n    if (_defaultHeight) {\n      _defaultHeight = parseFloat(defaultHeight) * parseFloat(fontSize);\n      this.set('_defaultHeight', _defaultHeight);\n      return _defaultHeight;\n    }\n\n    return parseFloat(defaultHeight) * parseFloat(fontSize);\n  },\n\n  /*\n   * Calculates pixel boundaries between visible, invisible,\n   * and culled content based on the \"viewport\" height,\n   * and the bufferSize.\n   *\n   * @private\n   */\n  _edges: null,\n  _computeEdges() {\n    let edges;\n\n    if (!this.radar || !this.radar.planet) {\n      edges = {};\n    } else {\n      // segment top break points\n      this.radar.planet.setState();\n\n      const bufferSize = this.get('bufferSize');\n      const rect = this.radar.planet;\n\n      edges = {\n        viewportTop: rect.top,\n        visibleTop: (-1 * bufferSize * rect.height) + rect.top,\n        viewportBottom: rect.bottom,\n        visibleBottom: (bufferSize * rect.height) + rect.bottom\n      };\n    }\n\n    this._edges = edges;\n    return edges;\n  },\n\n  /*\n   * Initialize\n   */\n  _prepareComponent() {\n    this.__smActionCache = {\n      firstReached: null,\n      lastReached: null,\n      firstVisibleChanged: null,\n      lastVisibleChanged: null\n    };\n\n    const collectionTagName = (this.get('tagName') || '').toLowerCase();\n    let itemTagName = this.get('itemTagName');\n\n    if (!itemTagName) {\n      if (collectionTagName === 'occlusion-collection') {\n        itemTagName = 'occlusion-item';\n      } else {\n        itemTagName = getTagDescendant(collectionTagName);\n      }\n    }\n    this.set('itemTagName', itemTagName);\n    this.radar = new ListRadar({});\n  },\n\n  _reflectContentChanges() {\n    const content = this.get('_content');\n\n    content.contentArrayDidChange = (items, offset, removeCount, addCount) => {\n      if (offset <= this.get('_firstVisibleIndex')) {\n        this.__prependComponents();\n      } else {\n        if (!removeCount || removeCount < addCount) {\n          this._scheduleUpdate();\n        }\n        this._scheduleSync();\n      }\n    };\n  },\n\n  _didReceiveAttrs(attrs) {\n    const oldArray = attrs.oldAttrs && attrs.oldAttrs.content ? attrs.oldAttrs.content.value : false;\n    const newArray = attrs.newAttrs && attrs.newAttrs.content ? attrs.newAttrs.content.value : false;\n\n    if (oldArray && newArray && this._changeIsPrepend(oldArray, newArray)) {\n      this.__prependComponents();\n    } else {\n      if (newArray && (!oldArray || get(oldArray, 'length') <= get(newArray, 'length'))) {\n        this._scheduleUpdate();\n      }\n\n      this._scheduleSync();\n    }\n  },\n\n  _changeIsPrepend(oldArray, newArray) {\n    const lengthDifference = get(newArray, 'length') - get(oldArray, 'length');\n\n    // if either array is empty or the new array is not longer, do not treat as prepend\n    if (!get(newArray, 'length') || !get(oldArray, 'length') || lengthDifference <= 0) {\n      return false;\n    }\n\n    // if the keys at the correct indexes are the same, this is a prepend\n    const oldInitialItem = valueForIndex(oldArray, 0);\n    const oldInitialKey = this.keyForItem(oldInitialItem, 0);\n    const newInitialItem = valueForIndex(newArray, lengthDifference);\n    const newInitialKey = this.keyForItem(newInitialItem, lengthDifference);\n\n    return oldInitialKey === newInitialKey;\n  },\n\n  _checkCssRules() {\n    if (this.$().css('display') !== 'block') {\n      Logger.warn('Verical-Collection needs a value of block on display property to function correctly');\n    }\n    if (isBlank(this.$().css('height'))) {\n      Logger.warn('Verical-Collection needs a value on height to function correctly');\n    }\n    if (isBlank(this.$().css('max-height'))) {\n      Logger.warn('Verical-Collection needs a value on max-height to function correctly');\n    }\n    if (this.$().css('position') !== 'relative') {\n      Logger.warn('Vertical-Collection needs a value of relative on position to function correctly');\n    }\n  },\n\n  didReceiveAttrs() {},\n\n  init() {\n    this._super();\n\n    this._prepareComponent();\n    this.set('_children', Ember.A());\n\n    if (this.get('useContentProxy')) {\n      this.set('_content', proxied.call(this, 'content', this.get('key')));\n      this._reflectContentChanges();\n    } else {\n      this.set('_content', computed.oneWay('content'));\n      this.set('didReceiveAttrs', this._didReceiveAttrs);\n    }\n  }\n});\n\nVerticalCollection.reopenClass({\n  positionalParams: ['items']\n});\n\nexport default VerticalCollection;\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/components/vertical-item/component.js":"import Ember from 'ember';\nimport layout from './template';\nimport getOwner from 'ember-getowner-polyfill';\nimport scheduler from '../../-private/scheduler';\n\nconst {\n  Component\n  } = Ember;\n\n/*\n A vertical-item is one that intelligently removes\n its content when scrolled off the screen vertically.\n\n @class vertical-item\n @extends Ember.Component\n @namespace Ember\n **/\nexport default Component.extend({\n  layout,\n  tagName: 'vertical-item',\n  itemTagName: 'vertical-item',\n\n  alwaysRemeasure: false,\n\n  classNames: ['vertical-item'],\n\n  next() {\n    const element = this.element.nextElementSibling;\n\n    return element ? this.registry[element.id] : null;\n  },\n\n  prev() {\n    const element = this.element.previousElementSibling;\n\n    return element ? this.registry[element.id] : null;\n  },\n\n  contentInserted: false,\n  _contentInserted: false,\n\n  /*\n   * Reveal the Element\n   *\n   */\n  show() {\n    if (this._contentInserted) {\n      return;\n    }\n\n    this._contentInserted = true;\n    this.set('contentInserted', true);\n    if (this.alwaysRemeasure) {\n      this.element.style.height = undefined;\n    }\n    scheduler.schedule('measure', () => {\n      // this.updateHeight();\n    });\n  },\n\n  /*\n   * Destroy the View/Element\n   *\n   * Unlike the other methods, this method\n   * can be called from any state. It is still not valid\n   * to transition to it directly, but willDestroy uses it\n   * to teardown the instance.\n   */\n  cull() {\n    if (!this._contentInserted) {\n      return;\n    }\n\n    // this.updateHeight();\n    if (this.alwaysRemeasure && this.element) {\n      if (this.setHeightProp) {\n        this.element.style.height = `${this.satellite.geography.height}px`;\n      }\n      this.element.style.minHeight = `${this.satellite.geography.height}px`;\n    }\n\n    this._contentInserted = false;\n    this.set('contentInserted', false);\n  },\n\n  _hasRealHeight: false,\n  updateHeight() {\n    const needsRealHeight = this.alwaysRemeasure;\n\n    if (needsRealHeight) {\n      this.satellite.resize();\n    }\n  },\n\n  defaultHeight: 75,\n  index: undefined,\n  content: undefined,\n  setHeightProp: false,\n\n  radar: undefined,\n  satellite: undefined,\n  registry: undefined,\n  registerSatellite(satellite) {\n    this.satellite = satellite;\n  },\n  unregisterSatellite() {\n    this.satellite = undefined;\n  },\n\n  _height: 0,\n\n  didInsertElement() {\n    this.radar.register(this);\n  },\n\n  willInsertElement() {\n    this._super();\n    const _height = this.get('_height');\n    let defaultHeight = this.get('defaultHeight');\n\n    if (typeof defaultHeight === 'number') {\n      defaultHeight = `${defaultHeight}px`;\n    }\n\n    let height = _height ? `${_height}px` : defaultHeight;\n\n    this.element.style.minHeight = height;\n\n    if (this.setHeightProp) {\n      this.element.style.height = height;\n    }\n  },\n\n  willDestroyElement() {\n    this._super();\n    this.set('contentInserted', false);\n    this._contentInserted = false;\n\n    if (this.radar) {\n      this.radar.unregister(this);\n    }\n    this.satellite = undefined;\n  },\n\n  willDestroy() {\n    this._super(...arguments);\n    this.unregister(this);\n\n    if (this.radar) {\n      this.radar.unregister(this);\n    }\n    this.satellite = undefined;\n    this.registry = undefined;\n  },\n\n  init() {\n    this._super();\n    this.registry = getOwner(this).lookup('-view-registry:main');\n    let tag = this.get('itemTagName');\n\n    this.set('tagName', tag);\n    tag = tag.toLowerCase();\n\n    const isTableChild = tag === 'tr' || tag === 'td' || tag === 'th';\n\n    // table children don't respect min-height :'(\n    this.setHeightProp = isTableChild || !this.alwaysRemeasure;\n    this.register(this);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/-debug/edge-visualization/debug-mixin.js":"import Ember from 'ember';\nimport Visualization from './visualization';\n\nconst {\n  computed,\n  Mixin\n  } = Ember;\n\nexport default Mixin.create({\n  debug: false,\n  showEdges: computed.alias('debug'),\n\n  _nextVisualization: null,\n\n  toggleEdgeVisualization() {\n    this.toggleProperty('debug');\n  },\n\n  visualization: null,\n  didInsertElement() {\n    this._super();\n    if (this.get('debug')) {\n      this.visualization = new Visualization(this);\n      requestAnimationFrame(() => {\n        this.visualize();\n      });\n    }\n  },\n\n  visualize() {\n    if (!this.get('debug')) {\n      if (this.visualization) {\n        this.visualization.destroy();\n        this.visualization = null;\n      }\n      return;\n    }\n\n    if (this.visualization) {\n      this.visualization.render();\n      requestAnimationFrame(() => {\n        this.visualize();\n      });\n    }\n  },\n\n  willDestroy() {\n    this._super();\n    if (this.visualization) {\n      this.visualization.destroy();\n      this.visualization = null;\n    }\n  }\n});\n\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/-debug/edge-visualization/visualization.js":"/* global document */\nimport Geography from '../../-private/radar/models/geography';\nimport Container from '../../-private/radar/models/container';\n\nconst SYS_WIDTH = 250;\n\nexport default class Visualization {\n  constructor(component) {\n    this.component = component;\n    this.minimumMovement = Math.floor(component.defaultHeight / 2);\n    this.radar = component.radar;\n    this.satellites = [];\n    this.cache = [];\n    this.setupViewport();\n    this.render();\n  }\n\n  setupViewport() {\n    this.wrapper = document.createElement('div');\n    this.wrapper.className = 'sm_visualization-wrapper';\n\n    this.container = document.createElement('div');\n    this.container.className = 'sm_visualization-container';\n    this.wrapper.appendChild(this.container);\n\n    this.sky = document.createElement('div');\n    this.sky.className = 'sm_visualization-skyline';\n    this.container.appendChild(this.sky);\n\n    this.telescope = document.createElement('div');\n    this.telescope.className = 'sm_visualization-telescope';\n    this.container.appendChild(this.telescope);\n\n    this.visAbove = document.createElement('div');\n    this.visAbove.className = 'sm_visualization-visible';\n    this.container.appendChild(this.visAbove);\n\n    this.visBelow = document.createElement('div');\n    this.visBelow.className = 'sm_visualization-visible';\n    this.container.appendChild(this.visBelow);\n\n    this.screen = document.createElement('div');\n    this.screen.className = 'sm_visualization-screen';\n    this.container.appendChild(this.screen);\n\n    document.body.appendChild(this.wrapper);\n  }\n\n  currentOffsetAdjustment() {\n    let currOffsets = this.radar.currentOffsets;\n\n    if (currOffsets !== null) {\n      const scrollY = currOffsets.top;\n      const scrollX = currOffsets.left;\n      const _scrollY = this.radar.scrollY;\n      const _scrollX = this.radar.scrollX;\n      const dY = scrollY - _scrollY;\n      const dX = scrollX - _scrollX;\n\n      return { dY, dX };\n    }\n\n    return { dY: 0, dX: 0 };\n  }\n\n  applySatelliteStyles(element, geography) {\n    const adj = this.currentOffsetAdjustment();\n    const left = SYS_WIDTH;\n\n    element.style.height = `${geography.height}px`;\n    element.style.top = `${geography.top - adj.dY}px`;\n    element.style.left = `${left}px`;\n  }\n\n  applySatelliteMirrorStyles(element, componentElement, compare) {\n    const adj = this.currentOffsetAdjustment();\n    const geography = new Geography(componentElement);\n    const left = 2 * SYS_WIDTH;\n    let errorLevel = false;\n\n    element.style.height = `${geography.height}px`;\n    element.style.top = `${geography.top}px`;\n    element.style.left = `${left}px`;\n\n    let diff = Math.abs(geography.top - compare.top + adj.dY);\n\n    if (diff > this.minimumMovement) {\n      errorLevel = true;\n    }\n\n    element.setAttribute('hasErrors', errorLevel ? 'true' : 'false');\n  }\n\n  static applyVerticalStyles(element, geography) {\n    element.style.height = `${geography.height}px`;\n    element.style.top = `${geography.top}px`;\n  }\n\n  static applyStyles(element, geography) {\n    Visualization.applyVerticalStyles(element, geography);\n    element.style.width = `${geography.width}px`;\n    element.style.left = `${geography.left}px`;\n  }\n\n  styleViewport() {\n    const edges = this.component._edges;\n    const {\n      planet,\n      skyline\n      } = this.radar;\n    this.container.style.height = `${planet.height}px`;\n\n    Visualization.applyVerticalStyles(this.telescope, planet);\n    Visualization.applyVerticalStyles(this.sky, skyline);\n\n    Visualization.applyVerticalStyles(this.screen, new Geography(Container));\n\n    Visualization.applyVerticalStyles(this.visAbove, {\n      top: edges.visibleTop,\n      height: edges.viewportTop - edges.visibleTop\n    });\n\n    Visualization.applyVerticalStyles(this.visBelow, {\n      top: edges.viewportBottom,\n      height: edges.visibleBottom - edges.viewportBottom\n    });\n  }\n\n  makeSatellite() {\n    let satellite;\n    let mirror;\n\n    if (this.cache.length) {\n      satellite = this.cache.pop();\n    } else {\n      satellite = document.createElement('div');\n      satellite.className = 'sm_visualization-satellite';\n    }\n    if (satellite.mirrorSatellite) {\n      mirror = satellite.mirrorSatellite;\n    } else {\n      mirror = document.createElement('div');\n      mirror.className = 'sm_visualization-mirror';\n      mirror.siblingSatellite = satellite;\n      satellite.mirrorSatellite = mirror;\n    }\n    this.satellites.push(satellite);\n    this.container.insertBefore(satellite, this.container.firstElementChild);\n    this.container.insertBefore(mirror, this.container.firstElementChild);\n  }\n\n  makeSatellites() {\n    const {\n      length\n      } = this.radar.satellites;\n    const isShrinking = this.satellites.length > length;\n\n    while (this.satellites.length !== length) {\n      if (isShrinking) {\n        const satellite = this.satellites.pop();\n\n        satellite.parentNode.removeChild(satellite);\n        satellite.mirrorSatellite.parentNode.removeChild(satellite.mirrorSatellite);\n        this.cache.push(satellite);\n      } else {\n        this.makeSatellite();\n      }\n    }\n    this.styleSatellites();\n  }\n\n  styleSatellites() {\n    const sats = this.satellites;\n\n    this.radar.satellites.forEach((sat, index) => {\n      const element = sats[index];\n      const satIndex = sat.component.get('index');\n\n      this.applySatelliteStyles(element, sat.geography);\n      element.setAttribute('viewState', sat.component._contentInserted ? 'visible' : 'culled');\n      element.mirrorSatellite.setAttribute('viewState', sat.component._contentInserted ? 'visible' : 'culled');\n      element.setAttribute('index', satIndex);\n      element.mirrorSatellite.setAttribute('index', satIndex);\n      element.innerText = satIndex;\n      this.applySatelliteMirrorStyles(element.mirrorSatellite, sat.component.element, sat.geography);\n      element.mirrorSatellite.innerText = satIndex;\n    });\n  }\n\n  render() {\n    this.styleViewport();\n    this.makeSatellites();\n  }\n\n  destroy() {\n    this.wrapper.parentNode.removeChild(this.wrapper);\n    this.wrapper = null;\n    this.radar = null;\n    this.component = null;\n    this.satellites.forEach((satellite) => {\n      satellite.mirrorSatellite = null;\n      satellite.siblingSatellite = null;\n      if (satellite.parentNode) {\n        satellite.parentNode.removeChild(satellite);\n      }\n    });\n    this.satellites = null;\n    this.cache.forEach((satellite) => {\n      satellite.mirrorSatellite = null;\n      satellite.siblingSatellite = null;\n      if (satellite.parentNode) {\n        satellite.parentNode.removeChild(satellite);\n      }\n    });\n    this.cache = null;\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/-private/ember/empty-object.js":"import emberRequire from './ext-require';\n\nexport default emberRequire('ember-metal/empty_object');\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/-private/ember/ext-require.js":"import Ember from 'ember';\n\nexport default function(moduleName, exportName = 'default') {\n  let module = Ember.__loader.require(moduleName);\n\n  return module[exportName];\n}\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/-private/scheduler/index.js":"import Ember from 'ember';\n\nconst {\n  run\n} = Ember;\n\nfunction Token() {\n  this.cancelled = false;\n}\nfunction job(cb, token) {\n  return function execJob() {\n    if (token.cancelled === false) {\n      cb();\n    }\n  };\n}\n\nexport class Scheduler {\n  constructor() {\n    this.sync = [];\n    this.layout = [];\n    this.measure = [];\n    this.affect = [];\n    this._nextFlush = null;\n  }\n\n  schedule(queueName, cb) {\n    let token = new Token();\n\n    this[queueName].push(job(cb, token));\n    this._flush();\n\n    return token;\n  }\n\n  forget(token) {\n    if (token) {\n      token.cancelled = true;\n    }\n  }\n\n  _flush() {\n    if (this._nextFlush !== null) {\n      return;\n    }\n\n    this._nextFlush = requestAnimationFrame(() => {\n      this._nextFlush = null;\n      this.flush();\n    });\n  }\n\n  flush() {\n    run.begin();\n    let i;\n    for (i = 0; i < this.sync.length; i++) {\n      run.schedule('actions', this.sync[i]);\n      this.sync[i] = undefined;\n    }\n    this.sync.length = 0;\n\n    for (i = 0; i < this.layout.length; i++) {\n      run.schedule('actions', this.layout[i]);\n      this.layout[i] = undefined;\n    }\n    this.layout.length = 0;\n\n    for (i = 0; i < this.affect.length; i++) {\n      run.schedule('afterRender', this.affect[i]);\n      this.affect[i] = undefined;\n    }\n    this.affect.length = 0;\n\n    for (i = 0; i < this.measure.length; i++) {\n      run.schedule('afterRender', this.measure[i]);\n      this.measure[i] = undefined;\n    }\n    this.measure.length = 0;\n    run.end();\n  }\n}\n\nexport default new Scheduler();\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/utils/element/apply-dimensions.js":"export default function applyDimensions(element, dimensions) {\n  for (const i in dimensions.style) {\n    if (dimensions.style.hasOwnProperty(i)) {\n      element.style[i] = i === 'boxSizing' ? dimensions.style[i] : `${dimensions.style[i]}px`;\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/utils/element/dim-from-str.js":"/* global parseFloat */\nexport default function dimFromStr(str) {\n  return str ? parseFloat(str) : 0;\n}\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/utils/element/get-dimensions.js":"import dimFromStr from './dim-from-str';\nimport getWidth from './get-width';\nimport getHeight from './get-height';\n\nexport default function getDimensions(element) {\n  const computedStyle = window.getComputedStyle(element, null);\n  const style = {\n    width: dimFromStr(computedStyle.width),\n    height: dimFromStr(computedStyle.height),\n    marginLeft: dimFromStr(computedStyle.marginLeft),\n    marginRight: dimFromStr(computedStyle.marginRight),\n    marginTop: dimFromStr(computedStyle.marginTop),\n    marginBottom: dimFromStr(computedStyle.marginBottom),\n    paddingLeft: dimFromStr(computedStyle.paddingLeft),\n    paddingRight: dimFromStr(computedStyle.paddingRight),\n    paddingTop: dimFromStr(computedStyle.paddingTop),\n    paddingBottom: dimFromStr(computedStyle.paddingBottom),\n    borderLeftWidth: dimFromStr(computedStyle.borderLeftWidth),\n    borderRightWidth: dimFromStr(computedStyle.borderRightWidth),\n    borderTopWidth: dimFromStr(computedStyle.borderTopWidth),\n    borderBottomWidth: dimFromStr(computedStyle.borderBottomWidth),\n    boxSizing: computedStyle.boxSizing,\n    fontSize: dimFromStr(computedStyle.fontSize),\n    lineHeight: dimFromStr(computedStyle.lineHeight)\n  };\n\n  return {\n    style,\n    calc: {\n      width: getWidth(style),\n      height: getHeight(style),\n      widthWithMargin: getWidth(style, true),\n      heightWithMargin: getHeight(style, true)\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/utils/element/get-height.js":"export default function getHeight(dims, withMargins) {\n  let height;\n\n  switch (dims.boxSizing) {\n  case 'border-box':\n    height = dims.height +\n      dims.borderTopWidth + dims.borderBottomWidth +\n      dims.paddingTop + dims.paddingBottom;\n    break;\n  case 'content-box':\n    height = dims.height;\n    break;\n  default:\n    height = dims.height;\n    break;\n  }\n  if (withMargins) {\n    height += dims.marginTop + dims.marginBottom;\n  }\n  return height;\n}\n","/home/travis/build/npmtest/node-npmtest-smoke-and-mirrors/node_modules/smoke-and-mirrors/addon/utils/element/get-width.js":"export default function getWidth(dims, withMargins) {\n  let width;\n\n  switch (dims.boxSizing) {\n  case 'border-box':\n    width = dims.width +\n      dims.borderLeftWidth + dims.borderRightWidth +\n      dims.paddingLeft + dims.paddingRight;\n    break;\n  case 'content-box':\n    width = dims.width;\n    break;\n  default:\n    width = dims.width;\n    break;\n  }\n  if (withMargins) {\n    width += dims.marginLeft + dims.marginRight;\n  }\n  return width;\n}\n"}